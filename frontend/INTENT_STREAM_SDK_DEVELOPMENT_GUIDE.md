# Intent-Stream SDK Development Guide
## Building an NPM CLI Package from Scratch

**Target Audience:** Developers with basic Node.js knowledge, no SDK experience  
**Goal:** Build `@intent-stream/cli` - A professional CLI tool for DeFi agent automation  
**Timeline:** 4 weeks (HackMoney 2026)

---

## Part 1: Understanding SDKs & CLI Tools

### What is an SDK?

**SDK = Software Development Kit**

Think of it as a toolbox that developers use to build applications:

```
Regular App:
User ‚Üí UI (buttons, forms) ‚Üí Your code ‚Üí Blockchain

SDK:
Other developer ‚Üí Your SDK functions ‚Üí Blockchain
                 ‚Üì
          (They build their own UI)
```

**For Intent-Stream:**
- **CLI SDK:** Developers type commands in terminal
- **JavaScript SDK:** Developers import functions in their code (future phase)

### What is a CLI Tool?

**CLI = Command Line Interface**

Examples you already know:
```bash
git commit -m "message"          # Git CLI
npm install package              # NPM CLI
intent-stream init               # Our CLI (what we're building)
```

### How CLIs Work

```
User types command in terminal
         ‚Üì
Terminal passes to Node.js
         ‚Üì
Commander.js library parses command
         ‚Üì
Your code executes the command
         ‚Üì
Result printed back to terminal
```

---

## Part 2: NPM Package Basics

### What is NPM?

**NPM = Node Package Manager**

It's like the App Store for JavaScript code:
- Developers publish packages (like apps)
- Other developers install packages
- Free hosting on npmjs.com

### Package Types

**1. Library Package (Imported in Code)**
```javascript
// User's code
import { helper } from 'your-package';
helper.doSomething();
```

**2. CLI Package (Run in Terminal)**
```bash
# User's terminal
your-command --flag value
```

**Intent-Stream is Type #2:** A CLI package

### How CLI Packages Work

**Step 1: User Installs**
```bash
npm install -g @intent-stream/cli
```
- `-g` = global (available everywhere)
- Creates command: `intent-stream`

**Step 2: NPM Creates Binary Link**
```
/usr/local/bin/intent-stream ‚Üí /node_modules/@intent-stream/cli/bin/index.js
```

**Step 3: User Types Command**
```bash
intent-stream init
```

**Step 4: Node.js Runs Your Code**
```javascript
// /bin/index.js
#!/usr/bin/env node
// ^ This line tells system to use Node.js

console.log("Running init command...");
```

---

## Part 3: Project Structure

### Folder Layout

```
intent-stream-cli/
‚îú‚îÄ‚îÄ package.json              # NPM configuration
‚îú‚îÄ‚îÄ tsconfig.json             # TypeScript configuration
‚îú‚îÄ‚îÄ README.md                 # Documentation
‚îú‚îÄ‚îÄ LICENSE                   # MIT license
‚îú‚îÄ‚îÄ .gitignore                # Files to ignore in Git
‚îú‚îÄ‚îÄ .npmignore                # Files to ignore in NPM
‚îÇ
‚îú‚îÄ‚îÄ bin/                      # Entry point (executable)
‚îÇ   ‚îî‚îÄ‚îÄ intent-stream.js      # Main command handler
‚îÇ
‚îú‚îÄ‚îÄ src/                      # Source code (TypeScript)
‚îÇ   ‚îú‚îÄ‚îÄ index.ts              # Main exports
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ commands/             # Command implementations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ init.ts           # intent-stream init
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stream.ts         # intent-stream stream
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ status.ts         # intent-stream status
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fund.ts           # intent-stream fund
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ history.ts        # intent-stream history
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ config.ts         # intent-stream config
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ lib/                  # Core functionality
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ wallet.ts         # Wallet management
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ channel.ts        # Yellow state channel interactions
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ broker.ts         # Broker communication
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ intent.ts         # Intent creation & signing
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ agent.ts          # ASI agent integration
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ crypto.ts         # Encryption helpers
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ utils/                # Helper utilities
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logger.ts         # Colored console output
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ formatter.ts      # Data formatting
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ascii.ts          # ASCII art
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.ts         # Config file management
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ errors.ts         # Error handling
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ types/                # TypeScript type definitions
‚îÇ       ‚îú‚îÄ‚îÄ intent.ts         # Intent types
‚îÇ       ‚îú‚îÄ‚îÄ channel.ts        # Channel types
‚îÇ       ‚îî‚îÄ‚îÄ config.ts         # Config types
‚îÇ
‚îú‚îÄ‚îÄ dist/                     # Compiled JavaScript (generated)
‚îÇ   ‚îî‚îÄ‚îÄ [auto-generated by TypeScript]
‚îÇ
‚îî‚îÄ‚îÄ tests/                    # Test files
    ‚îú‚îÄ‚îÄ commands/
    ‚îú‚îÄ‚îÄ lib/
    ‚îî‚îÄ‚îÄ utils/
```

---

## Part 4: Step-by-Step Development

### Phase 1: Project Setup (Day 1)

**Step 1: Initialize NPM Package**

```bash
# Create directory
mkdir intent-stream-cli
cd intent-stream-cli

# Initialize package
npm init -y

# Install TypeScript
npm install -D typescript @types/node

# Initialize TypeScript
npx tsc --init
```

**Step 2: Configure `package.json`**

```json
{
  "name": "@intent-stream/cli",
  "version": "0.1.0",
  "description": "Intent streaming SDK for MEV-proof DeFi agent automation",
  "main": "dist/index.js",
  "bin": {
    "intent-stream": "./bin/intent-stream.js"
  },
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch",
    "test": "jest",
    "prepublishOnly": "npm run build"
  },
  "keywords": [
    "defi",
    "ethereum",
    "yellow-network",
    "uniswap",
    "mev",
    "cli",
    "agent",
    "intent"
  ],
  "author": "Your Name <your@email.com>",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/intent-stream/cli"
  },
  "engines": {
    "node": ">=20.0.0"
  },
  "dependencies": {
    "commander": "^12.0.0",
    "ethers": "^6.10.0",
    "chalk": "^5.3.0",
    "ora": "^8.0.0",
    "inquirer": "^9.2.0",
    "conf": "^12.0.0",
    "axios": "^1.6.0",
    "ws": "^8.16.0",
    "boxen": "^7.1.0",
    "figlet": "^1.7.0",
    "cli-table3": "^0.6.3"
  },
  "devDependencies": {
    "@types/node": "^20.11.0",
    "@types/figlet": "^1.5.8",
    "@types/ws": "^8.5.10",
    "typescript": "^5.3.0",
    "jest": "^29.7.0",
    "@types/jest": "^29.5.0"
  }
}
```

**Step 3: Configure `tsconfig.json`**

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "CommonJS",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "tests"]
}
```

**Step 4: Create Entry Point `bin/intent-stream.js`**

```javascript
#!/usr/bin/env node

// This tells the system to use Node.js to run this file
// IMPORTANT: This must be line 1!

// Load the compiled CLI
require('../dist/index.js');
```

**Step 5: Make Binary Executable**

```bash
chmod +x bin/intent-stream.js
```

---

### Phase 2: Core CLI Framework (Day 2-3)

**File: `src/index.ts`**

```typescript
import { Command } from 'commander';
import figlet from 'figlet';
import chalk from 'chalk';
import { initCommand } from './commands/init';
import { streamCommand } from './commands/stream';
import { statusCommand } from './commands/status';
import { fundCommand } from './commands/fund';
import { historyCommand } from './commands/history';

// ASCII Art Banner
const banner = figlet.textSync('INTENT-STREAM', {
  font: 'ANSI Shadow',
  horizontalLayout: 'default',
});

console.log(chalk.yellow(banner));
console.log(chalk.white('Intent Streaming SDK for DeFi Agents'));
console.log(chalk.gray('MEV-Proof ‚Ä¢ Sub-Second ‚Ä¢ USDC-Native\n'));

// Initialize Commander
const program = new Command();

program
  .name('intent-stream')
  .description('CLI tool for streaming DeFi intents via Yellow Network')
  .version('0.1.0');

// Register commands
program
  .command('init')
  .description('Initialize agent wallet and state channel')
  .option('--network <chain>', 'Target network', 'arbitrum')
  .option('--fund <amount>', 'Initial funding amount')
  .action(initCommand);

program
  .command('stream')
  .description('Stream a trade intent')
  .requiredOption('--from <asset>', 'Source asset (e.g., ETH)')
  .requiredOption('--to <asset>', 'Destination asset (e.g., USDC)')
  .requiredOption('--amount <value>', 'Amount to swap')
  .option('--slippage <percent>', 'Max slippage %', '0.5')
  .option('--network <chain>', 'Target network', 'arbitrum')
  .option('--wizard', 'Use interactive wizard')
  .action(streamCommand);

program
  .command('status [intentId]')
  .description('Check intent execution status')
  .option('--watch', 'Watch for updates')
  .action(statusCommand);

program
  .command('fund')
  .description('Add funds to state channel')
  .requiredOption('--amount <value>', 'Amount to fund')
  .option('--asset <token>', 'Asset to fund', 'ETH')
  .option('--network <chain>', 'Target network', 'arbitrum')
  .action(fundCommand);

program
  .command('history')
  .description('View past intents')
  .option('--limit <number>', 'Number of intents', '10')
  .option('--all', 'Show all intents')
  .action(historyCommand);

program
  .command('config')
  .description('Manage configuration')
  .argument('<action>', 'get, set, or list')
  .argument('[key]', 'Config key')
  .argument('[value]', 'Config value')
  .action((action, key, value) => {
    // Config management logic
  });

// Parse command line arguments
program.parse(process.argv);

// If no command provided, show help
if (!process.argv.slice(2).length) {
  program.outputHelp();
}
```

---

### Phase 3: Command Implementation (Day 4-10)

**File: `src/commands/init.ts`**

```typescript
import chalk from 'chalk';
import ora from 'ora';
import boxen from 'boxen';
import { Wallet } from 'ethers';
import { createChannel } from '../lib/channel';
import { registerAgent } from '../lib/agent';
import { saveConfig, Config } from '../utils/config';
import { logger } from '../utils/logger';

interface InitOptions {
  network: string;
  fund?: string;
}

export async function initCommand(options: InitOptions) {
  logger.header('INTENT-STREAM INITIALIZATION');
  logger.divider();

  try {
    // Step 1: Generate wallet
    const spinner1 = ora('Generating agent wallet...').start();
    const wallet = Wallet.createRandom();
    spinner1.succeed(`Wallet created: ${chalk.cyan(wallet.address)}`);

    // Step 2: Request testnet tokens (mock for demo)
    const spinner2 = ora('Requesting FET tokens for agent staking...').start();
    await delay(1000);
    spinner2.succeed('Received 100 FET (testnet)');

    // Step 3: Connect to broker
    const spinner3 = ora('Connecting to StreamFlow broker...').start();
    const brokerUrl = 'wss://broker-01.streamflow.network';
    await delay(1000);
    spinner3.succeed(`Connected to broker: ${chalk.cyan('broker-01.streamflow.network')}`);

    // Step 4: Open Yellow state channel
    const spinner4 = ora('Opening Yellow state channel...').start();
    const channelId = await createChannel(wallet, options.network, options.fund);
    spinner4.succeed(`Channel opened: ${chalk.cyan(channelId)}`);

    // Step 5: Register ASI agent
    const spinner5 = ora('Registering ASI agent...').start();
    const agentId = await registerAgent(wallet, channelId);
    spinner5.succeed(`Agent registered with ID: ${chalk.cyan(agentId)}`);

    // Save configuration
    const config: Config = {
      version: '1.0.0',
      wallet: {
        address: wallet.address,
        encryptedKey: encryptPrivateKey(wallet.privateKey),
      },
      broker: {
        url: brokerUrl,
      },
      channels: {
        [options.network]: channelId,
      },
      agentId,
    };

    saveConfig(config);

    // Success message
    logger.divider();
    logger.success('INITIALIZATION COMPLETE');
    console.log();
    console.log(chalk.white('Next steps:'));
    console.log(chalk.gray('  1. Fund your agent wallet: ') + chalk.yellow('intent-stream fund'));
    console.log(chalk.gray('  2. Set spending limits: ') + chalk.yellow('intent-stream limit set <amount>'));
    console.log(chalk.gray('  3. Stream your first intent: ') + chalk.yellow('intent-stream stream --help'));

  } catch (error) {
    logger.error('Initialization failed', error);
    process.exit(1);
  }
}

function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function encryptPrivateKey(privateKey: string): string {
  // TODO: Implement encryption with user password
  // For now, return base64 encoded (INSECURE - fix for production)
  return Buffer.from(privateKey).toString('base64');
}
```

**File: `src/commands/stream.ts`**

```typescript
import chalk from 'chalk';
import inquirer from 'inquirer';
import { ethers } from 'ethers';
import { loadConfig } from '../utils/config';
import { createIntent, signIntent, encryptIntent } from '../lib/intent';
import { sendToMEV } from '../lib/broker';
import { logger } from '../utils/logger';
import { formatCurrency } from '../utils/formatter';

interface StreamOptions {
  from: string;
  to: string;
  amount: string;
  slippage: string;
  network: string;
  wizard?: boolean;
}

export async function streamCommand(options: StreamOptions) {
  // If wizard mode, get inputs interactively
  if (options.wizard) {
    options = await runWizard();
  }

  logger.header('STREAMING INTENT');
  logger.divider();

  try {
    // Load config
    const config = loadConfig();
    if (!config) {
      logger.error('Not initialized. Run: intent-stream init');
      process.exit(1);
    }

    // Display intent details
    console.log(chalk.white('Intent Details:'));
    logger.table([
      ['From Asset', options.from],
      ['To Asset', options.to],
      ['Amount', `${options.amount} ${options.from}`],
      ['Slippage', `${options.slippage}%`],
      ['Network', options.network],
    ]);
    console.log();

    // Step 1: Create intent
    logger.step(1, 'Creating intent...');
    const intent = await createIntent({
      from: options.from,
      to: options.to,
      amount: ethers.parseEther(options.amount),
      slippage: parseFloat(options.slippage),
      network: options.network,
      channelId: config.channels[options.network],
    });
    logger.stepSuccess();

    // Step 2: Sign intent
    logger.step(2, 'Signing with agent key...');
    const wallet = loadWallet(config);
    const signedIntent = await signIntent(intent, wallet);
    logger.stepSuccess();

    // Step 3: Encrypt intent
    logger.step(3, 'Encrypting intent...');
    const encryptedIntent = await encryptIntent(signedIntent, config.broker.publicKey);
    logger.stepSuccess();

    // Step 4: Stream to broker
    logger.step(4, 'Streaming to broker...');
    const intentId = await sendToBroker(encryptedIntent, config);
    logger.stepSuccess();

    // Display tracking info
    console.log();
    logger.info('Intent ID', intentId);
    logger.info('Track status', `intent-stream status ${intentId}`);

    // Optionally watch status
    const { watch } = await inquirer.prompt([
      {
        type: 'confirm',
        name: 'watch',
        message: 'Watch execution in real-time?',
        default: true,
      },
    ]);

    if (watch) {
      await watchIntent(intentId);
    }

  } catch (error) {
    logger.error('Intent streaming failed', error);
    process.exit(1);
  }
}

async function runWizard(): Promise<StreamOptions> {
  logger.header('INTENT STREAM WIZARD');
  logger.divider();

  const answers = await inquirer.prompt([
    {
      type: 'list',
      name: 'from',
      message: 'Select source asset:',
      choices: ['ETH', 'USDC', 'WBTC', 'ARB'],
    },
    {
      type: 'input',
      name: 'amount',
      message: 'Enter amount:',
      validate: (input) => {
        const num = parseFloat(input);
        if (isNaN(num) || num <= 0) return 'Please enter a valid number';
        return true;
      },
    },
    {
      type: 'list',
      name: 'to',
      message: 'Select destination asset:',
      choices: ['ETH', 'USDC', 'WBTC', 'ARB'],
    },
    {
      type: 'input',
      name: 'slippage',
      message: 'Maximum slippage tolerance (%):',
      default: '0.5',
    },
    {
      type: 'list',
      name: 'network',
      message: 'Select network:',
      choices: ['Arbitrum One', 'Base', 'Ethereum Mainnet'],
      filter: (val) => val.toLowerCase().replace(' ', '-'),
    },
  ]);

  return answers as StreamOptions;
}

async function watchIntent(intentId: string) {
  // Real-time status watching implementation
  // Uses WebSocket to broker for updates
  console.log(chalk.yellow('\n‚è±  Watching intent execution...'));
  // ... implementation
}

function loadWallet(config: Config): ethers.Wallet {
  // TODO: Decrypt private key with user password
  const privateKey = Buffer.from(config.wallet.encryptedKey, 'base64').toString();
  return new ethers.Wallet(privateKey);
}
```

---

### Phase 4: Utility Modules (Day 11-14)

**File: `src/utils/logger.ts`**

```typescript
import chalk from 'chalk';
import boxen from 'boxen';
import Table from 'cli-table3';

export const logger = {
  header(text: string) {
    console.log(
      boxen(chalk.yellow.bold(text), {
        padding: 1,
        margin: 1,
        borderStyle: 'double',
        borderColor: 'yellow',
      })
    );
  },

  divider() {
    console.log(chalk.gray('‚îÅ'.repeat(60)));
  },

  success(text: string) {
    console.log(chalk.green('üü¢ ' + text));
  },

  error(text: string, error?: any) {
    console.log(chalk.red('üî¥ ERROR: ' + text));
    if (error) {
      console.log(chalk.gray(error.message || error));
    }
  },

  info(label: string, value: string) {
    console.log(chalk.gray(`${label}: `) + chalk.white(value));
  },

  step(num: number, text: string) {
    process.stdout.write(chalk.gray(`[${num}] ${text}`));
  },

  stepSuccess() {
    console.log(chalk.green(' [‚úì]'));
  },

  table(data: Array<[string, string]>) {
    const table = new Table({
      chars: {
        top: '‚îÄ',
        'top-mid': '‚î¨',
        'top-left': '‚îå',
        'top-right': '‚îê',
        bottom: '‚îÄ',
        'bottom-mid': '‚î¥',
        'bottom-left': '‚îî',
        'bottom-right': '‚îò',
        left: '‚îÇ',
        'left-mid': '‚îú',
        mid: '‚îÄ',
        'mid-mid': '‚îº',
        right: '‚îÇ',
        'right-mid': '‚î§',
        middle: '‚îÇ',
      },
      style: {
        border: ['gray'],
        head: ['yellow'],
      },
    });

    data.forEach(([key, value]) => {
      table.push([chalk.gray(key), chalk.white(value)]);
    });

    console.log(table.toString());
  },
};
```

**File: `src/utils/config.ts`**

```typescript
import Conf from 'conf';
import os from 'os';
import path from 'path';

export interface Config {
  version: string;
  wallet: {
    address: string;
    encryptedKey: string;
  };
  broker: {
    url: string;
    publicKey?: string;
  };
  channels: {
    [network: string]: string;
  };
  agentId: string;
  preferences?: {
    defaultNetwork?: string;
    defaultSlippage?: number;
    colorOutput?: boolean;
  };
}

const config = new Conf<Config>({
  projectName: 'intent-stream',
  configName: 'config',
  cwd: path.join(os.homedir(), '.intent-stream'),
});

export function saveConfig(data: Config) {
  config.set(data);
}

export function loadConfig(): Config | null {
  if (!config.has('version')) {
    return null;
  }
  return config.store as Config;
}

export function getConfigValue<K extends keyof Config>(key: K): Config[K] | undefined {
  return config.get(key);
}

export function setConfigValue<K extends keyof Config>(key: K, value: Config[K]) {
  config.set(key, value);
}

export function clearConfig() {
  config.clear();
}
```

**File: `src/utils/ascii.ts`**

```typescript
export const ASCII_BANNER = `
‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù
‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   
‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   
‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   
‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïù   
                                                  
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ñà‚ïó
‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ïë
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïù ‚ñà‚ñà‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù
`;

export const SPINNER_FRAMES = ['‚†ã', '‚†ô', '‚†π', '‚†∏', '‚†º', '‚†¥', '‚†¶', '‚†ß', '‚†á', '‚†è'];

export const PROGRESS_BAR = (percent: number, width: number = 20): string => {
  const filled = Math.floor((percent / 100) * width);
  const empty = width - filled;
  return '[' + '‚ñà'.repeat(filled) + '‚ñë'.repeat(empty) + ']';
};
```

---

### Phase 5: Blockchain Integration (Day 15-21)

**File: `src/lib/channel.ts`**

```typescript
import { ethers, Wallet } from 'ethers';
import { logger } from '../utils/logger';

// Yellow Network State Channel Contract ABI (simplified)
const CHANNEL_ABI = [
  'function openChannel(address broker, uint256 depositETH) external payable',
  'function depositToChannel(bytes32 channelId, address token, uint256 amount) external',
  'function closeChannel(bytes32 channelId) external',
  'function getChannelBalance(bytes32 channelId, address token) external view returns (uint256)',
];

export async function createChannel(
  wallet: Wallet,
  network: string,
  fundAmount?: string
): Promise<string> {
  // Get network config
  const rpcUrl = getNetworkRPC(network);
  const channelContractAddress = getChannelContract(network);

  // Connect to network
  const provider = new ethers.JsonRpcProvider(rpcUrl);
  const signer = wallet.connect(provider);

  // Contract instance
  const channelContract = new ethers.Contract(
    channelContractAddress,
    CHANNEL_ABI,
    signer
  );

  // Broker address (StreamFlow's broker)
  const brokerAddress = '0xBROKER_ADDRESS'; // TODO: Get from config

  // Open channel with initial deposit
  const depositAmount = fundAmount ? ethers.parseEther(fundAmount) : ethers.parseEther('0.1');

  const tx = await channelContract.openChannel(brokerAddress, depositAmount, {
    value: depositAmount,
  });

  await tx.wait();

  // Generate channel ID (keccak256 of participants)
  const channelId = ethers.keccak256(
    ethers.AbiCoder.defaultAbiCoder().encode(
      ['address', 'address'],
      [wallet.address, brokerAddress]
    )
  );

  return channelId;
}

export async function fundChannel(
  wallet: Wallet,
  network: string,
  channelId: string,
  asset: string,
  amount: string
): Promise<void> {
  const rpcUrl = getNetworkRPC(network);
  const channelContractAddress = getChannelContract(network);

  const provider = new ethers.JsonRpcProvider(rpcUrl);
  const signer = wallet.connect(provider);

  const channelContract = new ethers.Contract(
    channelContractAddress,
    CHANNEL_ABI,
    signer
  );

  const tokenAddress = getTokenAddress(network, asset);
  const amountWei = ethers.parseEther(amount);

  // If ETH, send value
  if (asset === 'ETH') {
    const tx = await channelContract.depositToChannel(channelId, ethers.ZeroAddress, amountWei, {
      value: amountWei,
    });
    await tx.wait();
  } else {
    // For ERC20, first approve
    const tokenABI = ['function approve(address spender, uint256 amount) external returns (bool)'];
    const tokenContract = new ethers.Contract(tokenAddress, tokenABI, signer);

    const approveTx = await tokenContract.approve(channelContractAddress, amountWei);
    await approveTx.wait();

    // Then deposit
    const depositTx = await channelContract.depositToChannel(channelId, tokenAddress, amountWei);
    await depositTx.wait();
  }
}

function getNetworkRPC(network: string): string {
  const rpcs: { [key: string]: string } = {
    'arbitrum': 'https://arb1.arbitrum.io/rpc',
    'base': 'https://mainnet.base.org',
    'ethereum': 'https://eth.llamarpc.com',
  };
  return rpcs[network] || rpcs.arbitrum;
}

function getChannelContract(network: string): string {
  // TODO: Replace with actual deployed addresses
  const contracts: { [key: string]: string } = {
    'arbitrum': '0xCHANNEL_CONTRACT_ARBITRUM',
    'base': '0xCHANNEL_CONTRACT_BASE',
    'ethereum': '0xCHANNEL_CONTRACT_ETHEREUM',
  };
  return contracts[network] || contracts.arbitrum;
}

function getTokenAddress(network: string, symbol: string): string {
  const tokens: { [key: string]: { [symbol: string]: string } } = {
    'arbitrum': {
      'USDC': '0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8',
      'WBTC': '0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f',
    },
    // ... other networks
  };
  return tokens[network]?.[symbol] || ethers.ZeroAddress;
}
```

**File: `src/lib/intent.ts`**

```typescript
import { ethers, Wallet } from 'ethers';
import crypto from 'crypto';

export interface Intent {
  from: string;
  to: string;
  amount: bigint;
  slippage: number;
  network: string;
  channelId: string;
  nonce: number;
  deadline: number;
}

export interface SignedIntent extends Intent {
  signature: string;
}

export async function createIntent(params: Omit<Intent, 'nonce' | 'deadline'>): Promise<Intent> {
  return {
    ...params,
    nonce: Date.now(), // Simple nonce (use better approach in production)
    deadline: Math.floor(Date.now() / 1000) + 300, // 5 minutes from now
  };
}

export async function signIntent(intent: Intent, wallet: Wallet): Promise<SignedIntent> {
  // EIP-712 typed data
  const domain = {
    name: 'Intent-Stream-SDK',
    version: '1',
    chainId: getChainId(intent.network),
    verifyingContract: intent.channelId,
  };

  const types = {
    Intent: [
      { name: 'from', type: 'string' },
      { name: 'to', type: 'string' },
      { name: 'amount', type: 'uint256' },
      { name: 'slippage', type: 'uint256' },
      { name: 'nonce', type: 'uint256' },
      { name: 'deadline', type: 'uint256' },
    ],
  };

  const value = {
    from: intent.from,
    to: intent.to,
    amount: intent.amount,
    slippage: Math.floor(intent.slippage * 100), // Convert to basis points
    nonce: intent.nonce,
    deadline: intent.deadline,
  };

  const signature = await wallet.signTypedData(domain, types, value);

  return {
    ...intent,
    signature,
  };
}

export async function encryptIntent(
  intent: SignedIntent,
  brokerPublicKey: string
): Promise<Buffer> {
  // ECIES encryption
  // For simplicity, using AES-256-GCM (production should use proper ECIES)

  const intentJSON = JSON.stringify(intent);
  const key = crypto.randomBytes(32);
  const iv = crypto.randomBytes(16);

  const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);
  let encrypted = cipher.update(intentJSON, 'utf8', 'hex');
  encrypted += cipher.final('hex');

  const authTag = cipher.getAuthTag();

  // In production, encrypt the `key` with broker's RSA public key
  // For now, we'll just package everything together (INSECURE)

  const payload = {
    encrypted,
    iv: iv.toString('hex'),
    authTag: authTag.toString('hex'),
    key: key.toString('hex'), // THIS SHOULD BE ENCRYPTED!
  };

  return Buffer.from(JSON.stringify(payload));
}

function getChainId(network: string): number {
  const chainIds: { [key: string]: number } = {
    'arbitrum': 42161,
    'base': 8453,
    'ethereum': 1,
  };
  return chainIds[network] || 42161;
}
```

**File: `src/lib/broker.ts`**

```typescript
import WebSocket from 'ws';
import { logger } from '../utils/logger';
import { Config } from '../utils/config';

export async function sendToBroker(
  encryptedIntent: Buffer,
  config: Config
): Promise<string> {
  return new Promise((resolve, reject) => {
    const ws = new WebSocket(config.broker.url);

    ws.on('open', () => {
      // Send intent packet
      const packet = {
        type: 'INTENT',
        channelId: config.channels.arbitrum, // TODO: Dynamic network
        encryptedIntent: encryptedIntent.toString('base64'),
        timestamp: Date.now(),
      };

      ws.send(JSON.stringify(packet));
    });

    ws.on('message', (data: WebSocket.Data) => {
      const response = JSON.parse(data.toString());

      if (response.type === 'INTENT_ACK') {
        resolve(response.intentId);
        ws.close();
      } else if (response.type === 'ERROR') {
        reject(new Error(response.message));
        ws.close();
      }
    });

    ws.on('error', (error) => {
      reject(error);
    });

    // Timeout after 10 seconds
    setTimeout(() => {
      ws.close();
      reject(new Error('Broker connection timeout'));
    }, 10000);
  });
}

export async function watchIntentStatus(
  intentId: string,
  config: Config,
  callback: (status: any) => void
): Promise<void> {
  const ws = new WebSocket(config.broker.url);

  ws.on('open', () => {
    // Subscribe to intent updates
    ws.send(JSON.stringify({
      type: 'WATCH_INTENT',
      intentId,
    }));
  });

  ws.on('message', (data: WebSocket.Data) => {
    const update = JSON.parse(data.toString());
    callback(update);

    // Close when execution complete
    if (update.status === 'EXECUTED' || update.status === 'FAILED') {
      ws.close();
    }
  });

  ws.on('error', (error) => {
    logger.error('WebSocket error', error);
    ws.close();
  });
}
```

---

### Phase 6: Building & Testing (Day 22-25)

**Step 1: Build TypeScript to JavaScript**

```bash
npm run build
```

This creates `/dist` folder with compiled `.js` files.

**Step 2: Test Locally (Before Publishing)**

```bash
# Link package globally for testing
npm link

# Now you can run anywhere:
intent-stream --version
intent-stream init --network arbitrum
```

**Step 3: Write Tests**

```typescript
// tests/commands/init.test.ts
import { initCommand } from '../../src/commands/init';

describe('init command', () => {
  it('should create wallet and channel', async () => {
    // Test implementation
  });

  it('should save config file', async () => {
    // Test implementation
  });
});
```

Run tests:
```bash
npm test
```

---

### Phase 7: Publishing to NPM (Day 26)

**Step 1: Create NPM Account**

```bash
npm adduser
# Enter username, password, email
```

**Step 2: Prepare Package**

Create `.npmignore`:
```
src/
tests/
tsconfig.json
.git/
.gitignore
*.test.ts
```

Create `README.md`:
```markdown
# Intent-Stream SDK

CLI tool for streaming DeFi intents via Yellow Network.

## Installation

```bash
npm install -g @intent-stream/cli
```

## Quick Start

```bash
# Initialize agent
intent-stream init

# Stream an intent
intent-stream stream --from ETH --to USDC --amount 1.5

# Check status
intent-stream status <intent-id>
```

## Documentation

Full docs: https://docs.intent-stream.network
```

**Step 3: Publish**

```bash
# Test publishing (won't actually publish)
npm publish --dry-run

# Publish for real
npm publish --access public
```

**Step 4: Verify**

```bash
# Unlink local version
npm unlink -g @intent-stream/cli

# Install from NPM
npm install -g @intent-stream/cli

# Test
intent-stream --version
```

---

## Part 5: Agent Attributes & Configuration

### Configuration System

Users can set agent attributes via:

**1. Command-Line Flags**
```bash
intent-stream stream --from ETH --to USDC --amount 1.5 --slippage 0.5
```

**2. Config File (`~/.intent-stream/config.json`)**
```json
{
  "preferences": {
    "defaultNetwork": "arbitrum",
    "defaultSlippage": 0.5,
    "autoApproveUnder": 50
  }
}
```

**3. Interactive Prompts**
```bash
intent-stream config

? What would you like to configure?
  > Default network
    Spending limits
    Auto-approve threshold
    Color output
```

### Agent Attributes

**Spending Limits:**
```bash
# Set daily limit
intent-stream limit set daily 1000

# Set per-transaction limit
intent-stream limit set per-tx 500

# View current limits
intent-stream limit show
```

**Network Preferences:**
```bash
# Set default network
intent-stream config set defaultNetwork base

# View current default
intent-stream config get defaultNetwork
```

**Agent Strategies (ASI Integration):**
```bash
# Enable rebalancing strategy
intent-stream agent enable rebalancing --ratio 60/40

# Disable yield farming
intent-stream agent disable yield-farming

# List active strategies
intent-stream agent list
```

**Output Preferences:**
```bash
# Disable colored output
intent-stream config set colorOutput false

# Enable verbose logging
intent-stream --verbose stream ...

# JSON output (for scripting)
intent-stream status <id> --json
```

---

## Part 6: Testing Guide

### Manual Testing Checklist

Before publishing, test all commands:

```bash
# Installation
‚úì npm install -g @intent-stream/cli
‚úì intent-stream --version
‚úì intent-stream --help

# Initialization
‚úì intent-stream init
‚úì Verify config file created: ~/.intent-stream/config.json
‚úì Verify wallet address shown

# Configuration
‚úì intent-stream config list
‚úì intent-stream config set defaultNetwork base
‚úì intent-stream config get defaultNetwork

# Streaming
‚úì intent-stream stream --wizard
‚úì intent-stream stream --from ETH --to USDC --amount 0.1
‚úì intent-stream stream --from USDC --to ETH --amount 100 --slippage 1.0

# Status
‚úì intent-stream status <intent-id>
‚úì intent-stream status <intent-id> --watch

# History
‚úì intent-stream history
‚úì intent-stream history --limit 20
‚úì intent-stream history --all

# Funding
‚úì intent-stream fund --amount 1.0 --asset ETH
‚úì intent-stream fund --amount 5000 --asset USDC

# Error cases
‚úì intent-stream stream (without required args) ‚Üí Shows error
‚úì intent-stream status (not initialized) ‚Üí Shows error
‚úì intent-stream fund --amount -1 ‚Üí Shows validation error
```

### Automated Testing

```typescript
// tests/integration.test.ts
describe('Intent-Stream CLI Integration', () => {
  beforeAll(async () => {
    // Setup test environment
  });

  it('full flow: init ‚Üí stream ‚Üí status', async () => {
    // Run init
    await runCommand('init', ['--network', 'arbitrum']);

    // Run stream
    const result = await runCommand('stream', [
      '--from', 'ETH',
      '--to', 'USDC',
      '--amount', '0.1',
    ]);

    expect(result).toContain('Intent ID:');

    // Extract intent ID
    const intentId = extractIntentId(result);

    // Check status
    const status = await runCommand('status', [intentId]);
    expect(status).toContain('EXECUTED');
  });
});
```

---

## Part 7: Common Issues & Solutions

### Issue 1: "command not found: intent-stream"

**Cause:** Binary not linked correctly  
**Solution:**
```bash
npm link
# or
npm install -g . (from package directory)
```

### Issue 2: "Error: Cannot find module './dist/index.js'"

**Cause:** TypeScript not compiled  
**Solution:**
```bash
npm run build
```

### Issue 3: "Permission denied" when running command

**Cause:** Binary not executable  
**Solution:**
```bash
chmod +x bin/intent-stream.js
```

### Issue 4: NPM publish fails with "package already exists"

**Cause:** Version not incremented  
**Solution:**
```bash
# Bump version
npm version patch  # 0.1.0 ‚Üí 0.1.1
npm version minor  # 0.1.0 ‚Üí 0.2.0
npm version major  # 0.1.0 ‚Üí 1.0.0

# Then publish
npm publish
```

---

## Part 8: Next Steps After Initial Release

### Version 1.0 ‚Üí 2.0 Roadmap

**1. Add JavaScript/TypeScript SDK (Not Just CLI)**
```typescript
// Allow developers to import in code
import { IntentStream } from '@intent-stream/sdk';

const client = new IntentStream({
  wallet: myWallet,
  network: 'arbitrum',
});

await client.stream({
  from: 'ETH',
  to: 'USDC',
  amount: '1.5',
});
```

**2. Add React Hooks**
```typescript
import { useIntentStream } from '@intent-stream/react';

function MyComponent() {
  const { stream, status } = useIntentStream();

  const handleSwap = async () => {
    const intentId = await stream({
      from: 'ETH',
      to: 'USDC',
      amount: '1.5',
    });
  };

  return <button onClick={handleSwap}>Swap</button>;
}
```

**3. Add Python SDK**
```python
from intent_stream import IntentStream

client = IntentStream(
    wallet=my_wallet,
    network='arbitrum'
)

intent_id = client.stream(
    from_asset='ETH',
    to_asset='USDC',
    amount='1.5'
)
```

---

## Summary: From Zero to Published SDK

**Week 1: Foundation**
- Day 1: Project setup (package.json, tsconfig.json)
- Day 2-3: CLI framework (Commander.js, commands structure)

**Week 2: Core Features**
- Day 4-7: Implement commands (init, stream, status)
- Day 8-10: Blockchain integration (channels, intents)

**Week 3: Polish**
- Day 11-14: Utilities (logging, config, formatting)
- Day 15-17: Error handling, validation

**Week 4: Launch**
- Day 18-21: Testing (manual + automated)
- Day 22-24: Documentation (README, examples)
- Day 25-28: Publish to NPM, announce

**Result:** Professional CLI tool that developers can install with:
```bash
npm install -g @intent-stream/cli
```

---

## Resources

**Learning:**
- Commander.js docs: https://github.com/tj/commander.js
- Inquirer.js: https://github.com/SBoudrias/Inquirer.js
- Chalk: https://github.com/chalk/chalk
- Ethers.js: https://docs.ethers.org/v6/

**Examples:**
- Hardhat CLI: https://github.com/NomicFoundation/hardhat
- Foundry CLI: https://github.com/foundry-rs/foundry
- Viem CLI: https://github.com/wagmi-dev/viem

**Tools:**
- NPM Publishing Guide: https://docs.npmjs.com/cli/v10/commands/npm-publish
- TypeScript Handbook: https://www.typescriptlang.org/docs/

**Next Steps:**
1. Follow this guide step-by-step
2. Test each command as you build
3. Get feedback from early users
4. Iterate and improve

You now have everything needed to build a professional SDK from scratch!
